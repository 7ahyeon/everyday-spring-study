# Java Compile
1. 개발자 : 소스 코드 **(.java)** 작성
2. 자바 컴파일러 : 소스 코드(.java) 컴파일 > 바이트 코드 **(.class)** 파일
   - 바이트 코드(.class) : 자바 가상 머신(JVM)이 이해할 수 있는 코드(컴퓨터 X)
3. JVM 클래스로더 : 바이트 코드(.class) > 동적 로딩을 통해 JVM 메모리에 올림
   - 동적 로딩(Dynamic Loading) : 필요한 클래스 로딩 및 링크함
   - JVM 메모리 : 런타임 데이터 영역 (Runtime data area)
     - 클래스로더 세부 동작
       
|순서|동작|설명|
|:-:|:-:|:-:|
|a|로드|클래스 파일(바이트 코드) > JVM 메모리에 로드|
|b|검증|JLS 및 JVM 명세에 부합하는 구성인지 검사|
|c|준비|클래스가 필요로 하는 메모리 할당(필드, 메서드, 인터페이스 etc)|
|d|분석|클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경함|

* * *
# JVM
- 가상 머신 : 프로그램을 실행하기 위한 물리적 머신을 소프트웨어로 구현한 것
- 바이트 코드를 실행하고자 하는 하드웨어에 JVM을 동작시켜 자바 코드 변경 없이 여러 OS에서 동작하게 함
- 스택 기반! 계산 시 스택 사용 (<> 레지스터 기반! 계산할 때 레지스터 사용)
* * *
# 스택 기반 모델
- 계산할 때 스택 사용!
- JVM, .NetCLR etc

- 장점
  - 코드 작성 및 컴파일 용이 : 가상머신 빠름
  - 대상 하드웨어(레지스터, CPU 기능 등)를 직접 다루지 않음 : 다양한 하드웨어에서 구현 가능
  - 스택 포인터에 의한 피연산자 암시적 처리 : 피연산자 메모리 주소 포함 X > (비교적)하나의 명령어 코드가 더 작은 경향 있음
  - 동일한 피연산자 여러 번 푸시함

# 레지스터 기반 모델
- 계산할 때 레지스터 사용!
- 레지스터 : CPU가 요청을 처리 시 필요한 데이터를 일시적으로 저장함 (계산 수행 중인 값 저장)
- 장점
  - 실제 하드웨어와 비슷함
  - 적절한 양의 레지스터 할당 및 작업 : 작업량과 CPU 시간 절감 가능
  - 스택으로 밀고들어가는 오버 헤드 존재 X
  - 같은 연산 시 스택 기반 모델보다 적은 수의 명령어로 연산 수행 가능
